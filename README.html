<!DOCTYPE html><html><head><meta charset="utf-8"><style>html { font-size: 100%; overflow-y: scroll; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%; }

body{
  color:#444;
  font-family:Georgia, Palatino, 'Palatino Linotype', Times, 'Times New Roman',
              "Hiragino Sans GB", "STXihei", "微软雅黑", serif;
  font-size:12px;
  line-height:1.5em;
  background:#fefefe;
  width: 45em;
  margin: 10px auto;
  padding: 1em;
  outline: 1300px solid #FAFAFA;
}

a{ color: #0645ad; text-decoration:none;}
a:visited{ color: #0b0080; }
a:hover{ color: #06e; }
a:active{ color:#faa700; }
a:focus{ outline: thin dotted; }
a:hover, a:active{ outline: 0; }

span.backtick {
  border:1px solid #EAEAEA;
  border-radius:3px;
  background:#F8F8F8;
  padding:0 3px 0 3px;
}

::-moz-selection{background:rgba(255,255,0,0.3);color:#000}
::selection{background:rgba(255,255,0,0.3);color:#000}

a::-moz-selection{background:rgba(255,255,0,0.3);color:#0645ad}
a::selection{background:rgba(255,255,0,0.3);color:#0645ad}

p{
margin:1em 0;
}

img{
max-width:100%;
}

h1,h2,h3,h4,h5,h6{
font-weight:normal;
color:#111;
line-height:1em;
}
h4,h5,h6{ font-weight: bold; }
h1{ font-size:2.5em; }
h2{ font-size:2em; border-bottom:1px solid silver; padding-bottom: 5px; }
h3{ font-size:1.5em; }
h4{ font-size:1.2em; }
h5{ font-size:1em; }
h6{ font-size:0.9em; }

blockquote{
color:#666666;
margin:0;
padding-left: 3em;
border-left: 0.5em #EEE solid;
}
hr { display: block; height: 2px; border: 0; border-top: 1px solid #aaa;border-bottom: 1px solid #eee; margin: 1em 0; padding: 0; }


pre , code, kbd, samp { 
  color: #000; 
  font-family: monospace; 
  font-size: 0.88em; 
  border-radius:3px;
  background-color: #F8F8F8;
  border: 1px solid #CCC; 
}
pre { white-space: pre; white-space: pre-wrap; word-wrap: break-word; padding: 5px 12px;}
pre code { border: 0px !important; padding: 0;}
code { padding: 0 3px 0 3px; }

b, strong { font-weight: bold; }

dfn { font-style: italic; }

ins { background: #ff9; color: #000; text-decoration: none; }

mark { background: #ff0; color: #000; font-style: italic; font-weight: bold; }

sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; }
sup { top: -0.5em; }
sub { bottom: -0.25em; }

ul, ol { margin: 1em 0; padding: 0 0 0 2em; }
li p:last-child { margin:0 }
dd { margin: 0 0 0 2em; }

img { border: 0; -ms-interpolation-mode: bicubic; vertical-align: middle; }

table { border-collapse: collapse; border-spacing: 0; }
td { vertical-align: top; }

@media only screen and (min-width: 480px) {
body{font-size:14px;}
}

@media only screen and (min-width: 768px) {
body{font-size:16px;}
}

@media print {
  * { background: transparent !important; color: black !important; filter:none !important; -ms-filter: none !important; }
  body{font-size:12pt; max-width:100%; outline:none;}
  a, a:visited { text-decoration: underline; }
  hr { height: 1px; border:0; border-bottom:1px solid black; }
  a[href]:after { content: " (" attr(href) ")"; }
  abbr[title]:after { content: " (" attr(title) ")"; }
  .ir a:after, a[href^="javascript:"]:after, a[href^="#"]:after { content: ""; }
  pre, blockquote { border: 1px solid #999; padding-right: 1em; page-break-inside: avoid; }
  tr, img { page-break-inside: avoid; }
  img { max-width: 100% !important; }
  @page :left { margin: 15mm 20mm 15mm 10mm; }
  @page :right { margin: 15mm 10mm 15mm 20mm; }
  p, h2, h3 { orphans: 3; widows: 3; }
  h2, h3 { page-break-after: avoid; }
}
</style><title>README</title></head><body><h1 id="kobrascript">KobraScript</h1>
<p>KobraScript is a statically-typed language that compiles to JavaScript. The languages favors explicit declarations.</p>
<h4 id="kobra-demands-respect-hello-world">Kobra Demands Respect (Hello, world!)</h4>
<p>Say my name...</p>
<pre><code>say("Kobra!")                                    console.log("Kobra!");
</code></pre>
<h4 id="variable-declarations">Variable Declarations</h4>
<p>In KobraScript, variable declarations are simplified to one character: <code>$</code>. Add more details.</p>
<pre><code>$ name = "Samson"                                       var name = "Samson";

$ a, b, c = 5, 12, 13                                   var a = 5, b = 12, c = 13;

$ is_red = true,                                        var is_red = true,
  is_food = false,                                          is_food = false,
  is_mine = true                                            is_mine = true;
</code></pre>
<p>Variables with uninitialized values must be type-casted on declaration. The default value is set to undefined.</p>
<pre><code>$ total : int                                           var total = undefined;
</code></pre>
<h4 id="functions">Functions</h4>
<p>Functions in KobraScript take some inspiration from Java. Type of return is written in front of <code>fn</code> complying with the statically typed paradigm of KobraScript. Within the parameter of the function, a type can be specified or omitted for dynamic parameter input.</p>
<pre><code>--alternatively, (x : float[]) to take in a float array
floatfn average_intake (x):
    $ total = 0
    for ($ i = 0; i &lt; x.length; i++)
        total = total + x[i]
    }  
    say(total)
    return total / x.length
}
</code></pre>
<p>A function that does not return anything in KobraScript is called a procedure, written as <code>proc</code>. These have a special declaration, shown below.</p>
<pre><code>proc print_intake (y):
    say(average_intake(y))
end
</code></pre>
<h4 id="if-else-conditions"><code>if</code>-<code>else</code> Conditions</h4>
<p><code>If</code> and <code>else</code> conditions follow a similar paradigm as functions. In KobraScript, <code>if</code>-<code>else</code> conditional statement blocks should conclude with <code>..</code> to increase readability.</p>
<pre><code>if (is_red &amp;&amp; is_food):                                 if (is_red &amp;&amp; is_food) {
    eat ()                                                  eat ();
.. else if (is_food &amp;&amp; is_mine):                        } else if (is_food &amp;&amp; is_mine) {
    add_butter ()                                           add_butter ();
.. else:                                                } else {
    keep ()                                                 keep();
end                                                     }
</code></pre>
<p>Below is also another legal form of an if, else-if, else conditional statement, but this form is discouraged.</p>
<pre><code>if (is_red &amp;&amp; is_food):                                 if (is_red &amp;&amp; is_food) {
    eat ()                                                  eat ();
end else if (is_food &amp;&amp; is_mine):                       } else if (is_food &amp;&amp; is_mine) {
    add_butter ()                                           add_butter ();
end else:                                               } else {
    keep ()                                                 keep();
end                                                     }
</code></pre>
<h4 id="objects">Objects</h4>
<p>Objects are very similar in KobraScript to JavaScript. Braces are used specifically for objects, and nothing else.</p>
<pre><code>$ bicycle = {
    frame = "aluminum" : str,
    year = 2009 : int,
    gears = 10 : int,
    speed = 12.7 : float

    move = proc ():
        Transform.translate(FORWARD * this.speed)
    end,
    upgrade_speed = floatfn ():
        return this.speed = this.speed * 1.1
    end,
    get_frame = strfn (): return this.frame; end
}
</code></pre>
<h4 id="blueprints-classes">Blueprints (Classes)</h4>
<p>Blueprints are a form of class implementation in KobraScript. It allows for a robust way to define object properties and methods, and expediate the process of creating a complex object.</p>
<p>Blueprints consists of 4 parts:</p>
<ol>
<li><code>has</code>, which allows properties of the blueprint to be declared</li>
<li><code>does</code>, which allows functions of the blueprint to be declared</li>
<li><code>synget</code>, which allows <code>get_property()</code> functions to be created, and</li>
<li><code>synset</code>, which allows <code>set_property()</code> functions to be created.</li>
</ol>
<p>Here is an example of a blueprint of a robot.  </p>
<pre><code>$ blueprint Robot   -- initalizes the blueprint

$ has {
    id : bits8,
    year : int,
    energy_level = 100 : int,
    missle_container = (20, 20) : tuple2,
    base_speed = 320.0 : float,
    speed : float,
    users : str[]
}

$ does {
    Init = proc (id : bits8, year : int)
        this.id, this.year = id, year
        this.speed = this.base_speed
    },
    AddUser = boolfn (username : str)
        for ($ i = 0; i &lt; users.length; i++)
            return false if users[i].equals(username)
        }
        users = users.push(username)
        return true
    },
    SpeedBoost = floatfn (m : float)
        return speed = base_speed * m
    }
}

$ synget {
    id, year, energy_level, missle_container
}

$ synset {
    //no setters, structure unneccessary
}

defcc --definition concluded
</code></pre>
<h4 id="arrays">Arrays</h4>
<pre><code>$ protein_intake = [12, 21.3, 7.2, 20] : float[]    var protein_intake = [12.0, 21.3, 7.2, 20.0];
</code></pre>
<h4 id="for-and-while-conditions"><code>for</code> and <code>while</code> Conditions</h4>
<p>For and while loops follow a similar convention to functions: using the <code>:</code> and <code>end</code> syntax, and ...</p>
<pre><code>$ a = 0 -- A test variable for loops.               var a = 0; // A test variable for loops.

for ($ i = 0; i &lt; 4; i++):                          for (var i = 0; i &lt; 4; i++) {
    a++                                                 a++;
end                                                 }

while (a &lt; 10):                                     while (a &lt; 10) {
    a++                                                 a++;
end                                                 }
</code></pre>
<h3 id="macrosyntax">Macrosyntax</h3>
<pre><code>PROGRAM ::=  STMT+
        |    BLUPRNT

DEC     ::=  VARDEC  |  FNDEC
TYPE    ::=  ('bool' | 'char' | 'int' | 'float' | 'str' | 'bits' | ID)  ('[]')*
FNTYPE  ::=  TYPE  'fn'

ASSIGN  ::=  ID  '='  EXP  END
        |    ID  ':=:'  ID  END
BLOCK   ::=  ':'  STMT+  'end'
        |    ':'  STMT+  '..'
VARDEC  ::=  '$'  ID  '=' EXP  (':'  TYPE)?  END
        |    '$'  ID  ':'  TYPE  END
        |    '$'  ID  (',' ID)+  ('='  EXP  (','  EXP)?)?  (':'  TYPE)?  END
        |    '$'  (ID  '='  EXP (':'  TYPE)?  ',')*  ID  '='  EXP (':'  TYPE)?  END
FNDEC   ::=  (FN0  |  FN1  |  FN2)  END
FN0     ::=  '$'  ID  '='  FNTYPE  PARAMS  BLOCK
FN1     ::=  '$'  (ID  '='  FNTYPE  PARAMS  BLOCK  ',')*  FN0
FN2     ::=  FNTYPE  ID  PARAMS  BLOCK

BLUPRNT ::=  '$'  'blueprint'  ID  HASBLK  DOESBLK  SYNSET?  SYNGET?  'defcc'
        |    '$'  'blueprint'  ID  HASBLK  DOESBLK  SYNGET?  SYNSET?  'defcc'
HASBLK  ::=  '$'  'has'  '{'  VARDEC?  '}'
DOESBLK ::=  '$'  'does'  '{'  FNDEC?  '}'
SYNSET  ::=  '$'  'synset'  '{'  (ID ',')*  ID  '}'
SYNGET  ::=  '$'  'synget'  '{'  (ID ',')*  ID  '}'

VAR     ::=  ID
        |    VAR  '['  EXP  ']'
        |    VAR  '.'  ID

STMT    ::=  DEC
        |    DEC  'if'  EXP
        |    COND
        |    LOOP
        |    RETURN

LOOP    ::=  'while'  '('  EXP  ')'  BLOCK
        |    'for'  '('  (VARDEC)?  ';'  EXP  ';'  INCREMENT  ')'  BLOCK

COND    ::=  (COND0  |  COND1  |  COND2)
COND0   ::=  'if'  '('  EXP  ')'  BLOCK
COND1   ::=  COND0  'else if'  '('  EXP  ')'  BLOCK
COND2   ::=  (COND0  |  COND1)  'else'  BLOCK

EXP     ::=  EXP1 ('||' EXP1)*
EXP1    ::=  EXP2 ('&amp;&amp;' EXP2)*
EXP2    ::=  EXP3 (('&lt;' | '&lt;=' | '==' | '!=' | '&gt;=' | '&gt;') EXP3)?
EXP3    ::=  EXP4 ([+-] EXP4)*
EXP4    ::=  EXP5 ([*/] EXP5)*
EXP5    ::=  EXP6 (('**'  |  '-**')  EXP6)
EXP6    ::=  '~!'  EXP7 
        |    '~?'  EXP7 
EXP7    ::=  ('!')?  (EXP7  |  EXP8)
EXP8    ::=  'true' | 'false' | STR | INT | FLOAT | HEX | ID | '(' EXP ')'

RETURN  ::=  'return'  EXP  END
END     ::=  '\x09'  |  ';'

PARAM   ::=  ID (':' TYPE)?
        |    EXP (':' TYPE)?
PARAMS  ::=  '('  PARAM  (','  PARAM)*  ')'
INCR    ::=  VAR  "++"
        |    VAR  "--"
        |    VAR  "+="  int
        |    VAR  "-="  int
        |    VAR  "*="  int

COMMENT ::=  '--'  TEXT  END
        |    '---'  TEXT  '!--'
</code></pre>
<h3 id="microsyntax">Microsyntax</h3>
<pre><code>BITS    -&gt;  [01]*
INT     -&gt;  -?[\d]*
FLOAT   -&gt;  INT.\d*
HEX     -&gt;  (\d | [a-f] | [A-F])*
STR     -&gt;  \w+
BOOL    -&gt;  'true'  |  'false'
ID      -&gt;  [_a-zA-Z]\w*  --must not be on the banned list (i.e. tokens)
</code></pre></body></html>